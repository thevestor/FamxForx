# FamxForx
栈和队列
采用“后进先出”的存储结构
顺序栈
即用顺序表实现栈存储结构。使用栈存储结构操作数据元素必须遵守“先进后出”的原则。
例如：我们先使用顺序表(a数组)存储{1，2，3，4},存储状态如图
数组a:[1][2][3][4]
    a[0] a[1] a[2] a[3]
数组的存储形式主要以暴力存储的方式
而使用栈的存储结构{1，2，3，4},其存储状态为
[1][2][3][4] ——> 数据进栈
             <-- 数据出栈
通过数组的结构与栈的结构相比较，使用顺序表模拟栈结构较简单，只需要将数据从a数组下标为0的位置异常存储即可。
总结：从数组下标为0的模拟栈存储数据是常用的方法，从其他数组下标处存储数据也完全可以，这里只是为方方便初学者理解。
图数组中元素的消失仅是为了方便初学者学习，其实，这里只需要对top值做-1操作即可，因为top值本身就表示栈的栈顶位置，因此top-1就等同于栈顶元素出栈。
后期向栈中添加元素时，新元素会存储在类似元素4这样的旧元素位置上，将旧元素覆盖。
元素4和元素3全部出栈后，元素2才能出栈。因此，使用顺序表模拟数据出栈操作，都从一个元素入栈开始进栈操作进行匹配。

主体类方法代码如下
代码链接：https://github.com/thevestor/FamxForx/Stack/SqStack.java

总结：通过学习顺序表模拟栈中的数据入栈和出栈的操作，初学者完成了对顺序栈的学习。


链式栈的存储结构
括号匹配linkedlistStack.java
在一个表达式中含有圆括号或方括号等来表示运算的优先级的序列
例如：表达式[(A + B)*C]-[E - F]其中括号序列称为不匹配序列
匹配序列示例： ([()]) [][]() ()[()]
不匹配序列示例：([()]] ([)
栈的存储结构验证：
1.初始化一个空栈，顺序读入括号
2.若是左括号，则压入栈中
3.若全部元素遍历完毕，栈中仍然存在元素，则该序列不合法
1号位左小括号入栈，2号位左中括号入栈，3号位右中括号进栈，匹配2号位，出栈。
2号位右小括号入栈，匹配1号位，出栈
1号位左中括号入栈，2号位右中括号入栈，匹配1号位，出栈。
代码如下：
主体类:https://github.com/thevestor/FamxForx/Stack/Main.java
扩展：介绍Java hasNext()方法
在用户输入内容时，我们希望先输出“请输入”,然而系统提示为先输入内容，再输出“请输入：”.
于是利用hasNext()方法，我们可以发现，hasNext()返回的是boolean类型而next()返回的是你输入的那个值。，用户可以将输入的内容存储到sc中，然后通过查询sc，再调用用户输入的内容。

优化后栈的链式括号匹配
介绍：用户输入括号，通过函数判断是否匹配
主体类：https://github.com/thevestor/FamxForx/blob/main/stackTest/BalancedParan.java
